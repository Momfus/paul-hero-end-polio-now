<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>8</depth>
  <persistent>0</persistent>
  <parentName>parent_plat_cloud</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inialización de variables comunes.

{
    

    //Se guarda las coordenas de origen para reaparecer en ese lugar luego que el jugador muera.
    xo = x;
    yo = y;

    activado = true; // Señala si puede o no moverse (se detiene cuando el personaje muere por ejemplo).

    // Se señala que tipo de movimiento tiene el objeto cuando se crea ( 0 = horizontal / 1 = vertical )
        tipo = 0;
    
    /* Las sigueintes son las velocidades máximas que tiene la plataforma móvil y sus factores de velocidad que pueden variar con la aceleración.
    NOTA: Estas se asignan luego según el sub-objeto creado.*/
        max_h = 0;
        max_v = 0;
    
        ini_hsp = 0; // Velocidad horizontal inicial al crearse el objeto   \ Usados cuando se reinicia el nivel al morir el jugador.
        ini_vsp = 0; // Velocidad vertical inicial al crearse el objeto     /
            
        hsp = 0; // Velocidad horizontal
        vsp = 0; // Velocidad vertical
    
    // Factor de aceleración y desaceleración del objeto al comenzar a detenerse o moverse de un lado al otro.
        ace = 0;
    
    /* Las siguientes son las distancias que necesita la plataforma movil para detenerse completamente al lado del un "ob_stop_movil" y con velocidad
    cero según la velocidad máxima y la aceleración dada. NOTA: Tener en cuenta que para ahorrar esfuerzo de procesamiento se hace una sola vez y que
    el especio de movimiento de la plataforma móvil debe ser suficiente como para que cuando acelere llegue a la velocidad máxima.*/
    
        dis_des_h = 0;
        dis_des_v = 0;
        
    // La siguiente variable se va actualizando cuando la plataforma comienza a detenerse, para detectar correctamente la colisión según la velocidad que tiene.
    
        distancia_actualizada = 0;
        
    // Atributo usados para saber que objetos estan encima para moverlos primero, guarda el ID de la instancia a mover.
            
        move_jug = 0; // Señala si debe mover al jugador
        move_caja = 0; // Señala si debe mover a la caja.
    
    // Según el nombre del "hijo" que se crea, se da la velocidad horizontal y vertical necesaria, y todas las demas variantes..
    switch( object_index ){
    
        // PLATAFORMA NORMAL HORIZONTAL \\
        case ( ob_plat_movil_h ): {
        
            tipo = 0; // Movimiento horizontal.
        
            max_h = 3;        
            ace = 0.125;
        
            dis_des_h = dist_detenerse(max_h, ace);
            
            /* Se verifica de que lado comenzar (si hay un "ob_stop_movil" a la derecha se mueve a la izquierda primero, si es a la izquierda se mueve
            a la derecha, y sino se elige aleatoriamente uno de los dos*/
            if ( place_meeting( x + 1, y, ob_stop_movil ) ){ 
            
                hsp = -max_h;
                
                /* Al ser hacia a la izquierda, la velocidad máxima y el factor de aceleración son negativos ya que son usadas para marcar el 
                movimiento y hacia donde cambiar de dirección. */
                max_h = -max_h; 
                ace = -ace;
                
            }
            else{
            
                if ( place_meeting ( x - 1, y, ob_stop_movil ) ){ hsp = max_h; }
                else{
                
                    hsp = choose( -max_h, max_h );
                    
                    /* Si la velocidad asignada es negativa, al ser hacia a la izquierda, la velocidad máxima y el factor de aceleración son negativos 
                    ya que son usadas para marcar el movimiento y hacia donde cambiar de dirección.*/
                    if( hsp &lt; 0 ){ 
                    
                        max_h = -max_h; 
                        ace = -ace;
                            
                    }
                
                }
            
            }
            
            ini_hsp = hsp; // Valor usado para resetear la velocidad de la plataforma al reiniciarse la pantalla.
            
            distancia_actualizada = dis_des_h * sign(hsp) * (-1); // Toma un valor contrario al que se dirige la plataforma para que se reste correctamente
        
            break;
        
        }
        
        // PLATAFORMA NORMAL VERTICAL \\
        case ( ob_plat_movil_v ): {
        
            tipo = 1; // Movimiento vertical.
        
            hsp = 0; // No se usa asi que se coloca en cero (ya que el jugador puede accede de forma general a esta).
            
            max_v = 3;        
            ace = 0.125;
        
            dis_des_v = dist_detenerse(max_v, ace);
            
            
            /* Se verifica de que lado comenzar (si hay un "ob_stop_movil" arriba se mueve a abajo primero, si es abajo se mueve a arriba, y sino se 
            elige aleatoriamente uno de los dos. */
            if ( place_meeting( x, y + 1, ob_stop_movil ) ){ 
            
                vsp = -max_v;
                
                /* Al ser hacia a la izquierda, la velocidad máxima y el factor de aceleración son negativos ya que son usadas para marcar el 
                movimiento y hacia donde cambiar de dirección. */
                max_v = -max_v; 
                ace = -ace;
                
            }
            else{
            
                if ( place_meeting ( x, y - 1, ob_stop_movil ) ){ vsp = max_v; }
                else{
                
                    vsp = choose( -max_v, max_v );
                    
                    /* Si la velocidad asignada es negativa, al ser hacia arriba, la velocidad máxima y el factor de aceleración son negativos 
                    ya que son usadas para marcar el movimiento y hacia donde cambiar de dirección.*/
                    if( vsp &lt; 0 ){ 
                    
                        max_v = -max_v; 
                        ace = -ace;
                            
                    }
                
                }
            
            }
            
            ini_vsp = vsp; // Valor usado para resetear la velocidad de la plataforma al reiniciarse la pantalla.
            
            distancia_actualizada = dis_des_v * sign(vsp) * (-1); // Toma un valor contrario al que se dirige la plataforma para que se reste correctamente
            
            break;
            
        }
    
    }

    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
