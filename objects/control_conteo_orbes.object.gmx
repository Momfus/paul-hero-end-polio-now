<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-5</depth>
  <persistent>0</persistent>
  <parentName>ob_carteles</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inicio de atributos 

event_inherited(); // Se realizan primero las acciones "padre", de esta manera nos aseguramos que haga la misma animación de rebote.
pitch_rueda = 0.9; // Guarda los picos con el que irá aumentando el sonido al obtener una rueda rotaria.

//---&gt; Cambia las variables creadas en el objeto padre para que rebote donde se lo indique.
posicion_final_y = y + ( sprite_get_height(sp_cartel_conteo) / 2);


//---&gt; Utilizados para el manejo de este objeto y el conteo

    nivel_completo = false; // Cuando ya se ha terminado todo un nivel (se consiguieron todas las ruedas anteriormente), se usa esto para mostrar el mensaje correspondiente.
    salteado = false; // Usado para indicar si se presiona alguna de las teclas correspondientes a saltearse el conteo.

    // Centro a utilizar el objeto
    centro_x = sprite_get_width(sp_cartel_conteo) / 2;
        
    // Se recoloca el objeto para que se dibuje donde corresponde.
    x = x - centro_x;
    
    // Atributos de control del conteo de orbes.
    orbes_contando = 0;
    orbes_conseguidas = control_general.nivel_orbes_cantidad_actual;
    orbes_total = control_general.nivel_orbes_cantidad_total;
    
    /* Se carga la cantidad de ruedas que se consiguió la última vez que se estuvo en el nivel y se copia el dato a la cantidad de ruedas que se irá 
    contando, además de mostrar en pantalla en el evento Draw*/
    cantidad_ruedas_nivel_antes = cargar_total_ruedas_nivel(control_general.datos[1], sector_actual, nivel_actual); 
    cantidad_ruedas_nivel_contando = cantidad_ruedas_nivel_antes;
    
    
    // Las siguientes marcan el limite redondeado hacia arriba para conseguir las 3 ruedas rotarias 
    obtener_rueda[0] = ceil(orbes_total * 0.3);
    obtener_rueda[1] = ceil(orbes_total * 0.6);
    obtener_rueda[2] = orbes_total;
    
    
    /* Se llama a la alarma que hace comenzar el conteo de puntaje en el caso de tener menos de 3 ruedas rotarias, sino se llama a la encargada de 
    pasar de nivel...además de señalar que se tienen todas las orbes de una. */
    if( cantidad_ruedas_nivel_antes != 3 ){ alarm[0] = 30; }
    else{ 
    
        nivel_completo = true;
        alarm[1] = 60; 
        
    }
    
    // La siguiente variable vale "true" si el nivel se habia hecho antes o "false" si es la primera vez (se usa posteriormente en el time_fin_nivel)
    if( nivel_actual != 11 ){ nivel_rehecho = verificar_desbloqueo_siguiente_nivel( "save.data", control_general.datos[1], nivel_actual ); }
    else{ nivel_rehecho = true; }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Terminar nivel

// Si se superó la cantidad de ruedas obtenidas la última vez, se guarda la nueva cantidad
if( cantidad_ruedas_nivel_contando &gt; cantidad_ruedas_nivel_antes ){

    var ruedas_sumar = cantidad_ruedas_nivel_contando - cantidad_ruedas_nivel_antes;
    guardar_total_ruedas_nivel("save.data", sector_actual, nivel_actual, cantidad_ruedas_nivel_contando, orbes_conseguidas, ruedas_sumar );
    
}

// Se verifica si el siguiente nivel (o el sector si se esta en un nivel final) esta desbloqueado mientras no sea el último del juego.
if not( sector_actual == 6 and nivel_actual == 11  ){ 

    if not( sector_actual == 6 and nivel_actual == 10 ){
    
        //Se verifica además que no sea el penúltimo sector ni el penúltimo nivel para no desbloquear el sector extra normalmente
        if not( sector_actual == 5 and nivel_actual == 10 ){
        
            verificar_para_desbloquear("save.data", sector_actual, nivel_actual); 
            
        }
    
    }
    
}

ob_jug.timeline_running = true; // Se activa el timeline asociado al jugador que hace que se termine el nivel

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Conteo de orbes

// Se ira incrementando el contador hasta llegar la cantidad que se ha conseguido.
if( orbes_contando &lt; orbes_conseguidas ){

    orbes_contando++;

    if( obtener_rueda[cantidad_ruedas_nivel_contando] == orbes_contando ){
   
        var pos_x = x + ( 80 * cantidad_ruedas_nivel_contando );
        effect_create_above( ef_ring, pos_x, y, 0, c_yellow );
        
        cantidad_ruedas_nivel_contando++;
        
        //[Sonido]
        audio_sound_pitch( sn_rueda_obtenida, pitch_rueda );
        audio_play_sound( sn_rueda_obtenida, 8, false );
        
        pitch_rueda += 0.2;
        
    
    }
        
    alarm[0] = 4;

}
else{

    // Se llama a la alarma que activa el timeline de fin nivel para que siga como iba
    alarm[1] = 15;

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Manejo del efecto rebote

event_inherited(); // Se maneja desde el evento del objeto padre.
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Se verifica si se realiza un salteo del conteo

/* Se verifica si se esta presionando alguna tecla correspondiente a saltear el contro, si aún no se salteo y la animación de caida del cartel terminó...en ese
caso se da el resultado final y se finaliza el nivel.*/
var tecla_saltear_conteo = keyboard_check_released( tecla_jump ) or keyboard_check_released( tecla_interac ) or keyboard_check_released( tecla_salir ),
    usar_sonido = false;;

if( tecla_saltear_conteo == true and salteado = false and etapa == 3 and nivel_completo == false ){

    // El siguiente bucle se cumple hasta terminar con el conteo de las orbes.
    while( orbes_contando &lt; orbes_conseguidas ){
    
        orbes_contando++;
    
        if( obtener_rueda[cantidad_ruedas_nivel_contando] == orbes_contando ){
   
            var pos_x = x + ( 80 * cantidad_ruedas_nivel_contando );
            effect_create_above( ef_ring, pos_x, y, 0, c_yellow );
            
            cantidad_ruedas_nivel_contando++;
            
            if( usar_sonido == false ){ usar_sonido = true; }
        
        }
    
    }
    
    // Se llama a la larma que realiza las acciones luego dle conteo y se marca que se ha salteado.
    alarm[1] = 15;
    salteado = true;
    
    //[Sonido]
    if( usar_sonido == true ){ audio_play_sound( sn_rueda_obtenida, 8, false ); }

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Manejo del sprite

//---&gt; Se oscurece un poco el fondo para resaltar el cartel
draw_set_colour(c_black);
draw_set_alpha( 0.75 );
draw_rectangle( 0, 0, room_ancho, room_alto, false );
draw_set_alpha( 1 );

//---&gt; Cartel de fondo
draw_sprite(sp_cartel_conteo, 0, x, y);
        
// Texto Nivel (nro sector) - (nro nivel dentro del sector).
draw_set_halign(fa_center);
draw_set_valign(fa_middle);
draw_set_font(fn_principal_normal);
draw_set_color(c_white);
        
draw_text( x + centro_x, y - 140, "Level " + string(sector_actual) + " - " + string(nivel_actual) );
       
// Si el nivel no ha sido terminado anteriormente, se muestra la orbe y lo que se va contando, sino se muestra el mensaje correspondiente.
if( nivel_completo == false ){

    // Orbe
    draw_sprite_ext(sp_orbe, 1, x + centro_x - 8, y - 90, 1.2, 1.2, 0, c_white, 1);
            
    // Conteo orbes (nro contando) - (nro total de orbes en el nivel).
    draw_set_font(fn_principal_big);
    draw_text( x + centro_x, y - 45, string_replace( string_format(orbes_contando, 2, 0), ' ', '0') + " / " + string_replace( string_format(orbes_total, 2, 0), ' ', '0') );
            
}
else{ draw_text_transformed( x + centro_x, y - 60, "Level#complete!", 1.1, 1.1, 0 ); }

// Se dibujan las ruedas según la cantidad que se tenía o se consigue en el momento.
        
var y_pos = y - 24;
        
switch( cantidad_ruedas_nivel_contando ){
        
    case 0:{
                
        draw_sprite(sp_rueda_rotaria_grande_conteo, 1, x - 24, y_pos );
        draw_sprite(sp_rueda_rotaria_grande_conteo, 1, x + 56, y_pos );
        draw_sprite(sp_rueda_rotaria_grande_conteo, 1, x + 136, y_pos );
                        
        break;
                
    }
                
    case 1:{
                
        draw_sprite(sp_rueda_rotaria_grande_conteo, 0, x - 24, y_pos );
        draw_sprite(sp_rueda_rotaria_grande_conteo, 1, x + 56, y_pos );
        draw_sprite(sp_rueda_rotaria_grande_conteo, 1, x + 136, y_pos );
                    
        break;
                
    }
                
    case 2:{
                
        draw_sprite(sp_rueda_rotaria_grande_conteo, 0, x - 24, y_pos );
        draw_sprite(sp_rueda_rotaria_grande_conteo, 0, x + 56, y_pos );
        draw_sprite(sp_rueda_rotaria_grande_conteo, 1, x + 136, y_pos );
                    
        break;
                
    }
            
    case 3:{
                    
        draw_sprite(sp_rueda_rotaria_grande_conteo, 0, x - 24, y_pos );
        draw_sprite(sp_rueda_rotaria_grande_conteo, 0, x + 56, y_pos );
        draw_sprite(sp_rueda_rotaria_grande_conteo, 0, x + 136, y_pos );
                    
        break;    
                
    }
            
}     
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
