<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sp_bloque_sector</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>parent_rebote</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Atributos de sector

timeline_index = time_vibrar; // Animación usada cuando esta bloqueado y se selecciona.

numero = 0; // Cualquier valor entero, el cero es de prueba.

desbloqueado = false; // El "numero 1" debe estar en "true".

niveles_desbloqueados = 0; // El total siempre es 11 ( 10 comunes + 1 especial ).

ruedas_obtenidas = 0; // El total es siempre 33 ( 3 ruedas rotarias * 11 niveles totales). 

mostrar_planilla = false; // Se activa desde el "control_menu_pausa" al moverse el puntero y muestra una planilla que indica diversa información del sector.

extra = false; // Para señalar si el sector es el extra.

// Los siguientes atributos son para controlar el efecto de rebote
image_speed = 0;
etapa = 3; // Para manejar el efecto de rebote (menos a 3) y cuando se termina la animación. Se comienza en 3 para que quede quieto en un inicio.
vel = 0; // Velocidad en que se mueve el cartel al caer (se inicializa en cero pero en la alarma que se llama se coloca otro valor, dando un efecto cascada con el resto)..

posicion_final_y = y // Se toma como posición final la que tiene al colocarse en el room.

y = 0 - ( room_alto - posicion_final_y ); // Se coloca el objeto sobre la pantalla para que luego caiga donde estaba de forma ordenada.

alarm[0] = 1; // Se llama la alarma que hace caer los bloques.

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Se activa caida de los bloques 

etapa = 0; // Se activa la animación.
vel = 30 + irandom(10); 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Manejo de la animación del objeto y posicionamiento al rebotar

// Si la etapa no es "3", se realiza la animación, sino se hace lo necesario según que tipo de cartel es.
if( etapa != 3 ){

    switch( etapa ){
    
        // Bajando pasando por 16 pixeles la posición deseada.
        case 0:{
        
            if( y &lt; ( posicion_final_y + 16 - vel ) ){ y += vel; if( vel &lt; 20 ){ vel += grav; } }
            else{ etapa++; vel = 10; }
            
            break;
        
        }
        
        // Sube hasta 8 pixeles por encima de la posición deseada
        case 1:{
        
            if( y &gt; ( posicion_final_y - 8 ) ){ y -= vel; if( vel != 0 ){ vel -= grav; } }
            else{ etapa++; vel = 5; }
            
            break;
        
        }
        
        // Baja hasta la posición deseada
        case 2:{
        
            if( y &lt; posicion_final_y ){ y += vel; if( vel &lt; 20 ){ vel += grav; } }
            else{ etapa++; y = posicion_final_y }
        
            break;
        
        }
    
    }
    
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Manejo de la imagen

// Se verifica si el sector esta bloqueado o no, para saber si se dibujar el candado.
if( desbloqueado == true ){

    
    // Se muestra la planilla de información si la variable correspondiente a su control esta habiltiada.
    if( mostrar_planilla == true ){ 
    
        // Se coloca la fuente correspondiente.
        draw_set_font(fn_principal_big);
        draw_set_halign(fa_center);
        draw_set_valign(fa_middle);
        draw_set_color(c_yellow);
    
        // Se verifica si no es un sector extra (que el sprite es distinto).
        if( extra == false ){
    
            // Sprite de fondo con número
            draw_sprite(sp_bloque_sector, 0, x, y);
            
            draw_text_transformed( x + 30, y + 36, numero, 0.9, 0.9, 0 );
        
        }
        else{
        
            // Sprite de fond
            draw_sprite_ext(sp_bloque_sector, 2, x - 16, y - 12, 1.5, 1.5, 0, -1, 1);
            
        
        }
    
        // Dibujo de la planilla
        draw_sprite(sp_plantilla_sector, 0, x + 32, y - 8); 
        
        draw_sprite(sp_candado_abierto, 0, x - 32, y - 96);
        draw_sprite_ext(sp_rueda_rotaria_grande, 2, x - 30, y - 52, 0.8, 0.8, 0, -1, 1);
           
        // Información de la misma.
        draw_set_font(fn_principal_normal);
        draw_set_halign(fa_right);
        draw_set_valign(fa_top);
        draw_set_color(c_white);
        
        draw_text( x + 96 , y - 96, string(niveles_desbloqueados) + " / 11 ");
        draw_text( x + 96, y - 48, string(ruedas_obtenidas) + " / 33 ");
        
    }
    else{
    
        // Se coloca la fuente correspondiente.
        draw_set_font(fn_principal_big);
        draw_set_halign(fa_center);
        draw_set_valign(fa_middle);
        draw_set_color(c_white);
    
        // Se verifica si no es un sector extra (que el sprite es distinto).
        if( extra == false ){
    
            // Sprite de fondo con número
            draw_sprite(sp_bloque_sector, 0, x, y);
            
            draw_text_transformed( x + 30, y + 36, numero, 0.9, 0.9, 0 );
        
        }
        else{
        
            // Sprite de fondo 
            draw_sprite_ext(sp_bloque_sector, 2, x - 16, y - 12, 1.5, 1.5, 0, -1, 1);
            
        
        }
    
    }
    
    
}
else{

    // Se verifica si no es un sector extra (que el sprite es distinto).
    if( extra == false ){ draw_sprite(sp_bloque_sector, 1, x, y); }   
    else{ draw_sprite_ext(sp_bloque_sector, 3, x - 16, y - 12, 1.5, 1.5, 0, -1, 1); }
    
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>32,32</point>
  </PhysicsShapePoints>
</object>
