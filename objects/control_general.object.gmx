<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>100</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inicio de atributos de control general.
{

    mostrar_creditos_final = false; // Se vuelve verdadero cuando se muestra la cutscene final, para que vaya directo a esa opción sin pasar por las opciones

    //--- Usados para el manejo de animación al desbloquear nivel o sector especial.
    bloque_extra_id = 0;
    repeticion_vibracion = 0;
    
    /* Se crea una pila "FIFO" que sirve para que al crearse una flecha se guarde en la pila y en vez de destruirse y crearse de nuevo, se desactiva y 
    queda almecenado para que cuando se requiera vuelva a usarse. En el caso que la flecha aun está en uso, se crea otra en la dirección deseada. Esto 
    se llama "polling"*/
    globalvar cola_flechas;
    cola_flechas  = ds_queue_create();
    
    //--- Creación y definición del path a usar cuando el jugador llega a "ob_punto_entrega"
    
    pth_jug_fin_nivel = path_add(); // Se crea el path.
    path_set_closed( pth_jug_fin_nivel, false );

    //--- Atributos de selección (niveles y sectores)
    
    datos = ""; // Arreglo que en cada posición guardará una cadena de datos sacadas de los archivos.
    
    var nombre_archivo = "save.data";
    
    crear_save(nombre_archivo);   
    
    datos = cargar_datos(nombre_archivo); /*
    
                                                datos[0] = valores de los sectores
                                                datos[1] = valores de los niveles
    
                                          */
                  
    //--- Atributos de sector (los que dicen juego al principio son por el "conjunto de sectores", los demas son por cada sector)
    
        juego_total_ruedas = cargar_total_ruedas_juego( datos[0] ); /* Recordar que al terminar un nivel y obtener ruedas se modifica el valor directamente 
        //                                                            luego de guardar el dato (para no estar cargando los datos continuamente del archivo) */
                                                            
        /* Se guarda en un arreglo los totales individuales de las ruedas obtenidas por cada sector (la posición cero no se tiene en cuenta), recordar
        modificar el valor correspondiente al obtener una nueva rueda despues de guardar el archivo en el fichero (de esta manera no se está constantemente
        cargando dato alguno de un archivo)*/
        
        for( var i = 1; i &lt;= 6; i++ ){ sector_total_ruedas[i] = cargar_total_ruedas_sector( datos[1], i ); }
        
        globalvar sector_actual; // Usado para saber que sector elije el jugador y también donde posicionar el puntero al volver del selector de sectores                          
        sector_actual = 1;
        
        sector_siguiente_desbloqueado = false; /* Su valor cambia al comenzar el room de selección de niveles, True = se habilita el boton de ir a siguiente sector
                                                sino no se muestra hasta que se desbloquee*/
                   
    //--- Atributos del nivel
    
        globalvar nivel_actual; // Usado para saber que nivel elije el jugador y también donde posicionar el puntero al volver del selector de niveles  
        nivel_actual = 1;
    
        nivel_orbes_cantidad_total = 0; // Se encarga de inicializarlo el código del room
        nivel_orbes_cantidad_actual = 0; // Se encarga de inicializarlo el código del room y al morir se reinicia a cero.
    
        en_menu = true;
        
    //--- Manejo de Backgrounds
    
        globalvar tipo_fondo;
        tipo_fondo = 0; // Usado para indicar luego (en el código de creación de niveles) que tipo de fondo utilizar.
 
    
               
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// ATRIBUTOS PRUEBA

globalvar prueba;
prueba = false;

ver = false;



grilla_prueba = false;


//para el manejo del valor real que usa cpu por segundo
fps_str = "";
fps_old = fps_real;
time = get_timer();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inicio Atributos de controles / teclado

globalvar tipo_control; /* Especifica que tipo de control se implementa:    0 = WASD + J / K
                                                                            1 = Flechas + X / Z
                        */

// Las siguientes variables globales guardan el valor ASCII de los controles a utilizar.
globalvar tecla_right, tecla_left, tecla_up, tecla_down, tecla_jump, tecla_interac, tecla_salir;

tecla_jump = 0;
// Las siguientes guardan el "ID" del sprite a usar para tutoriales y menues dependiendo el tipo de control deseado.
globalvar sprite_tecla_right, sprite_tecla_up, sprite_tecla_down, sprite_tecla_jump, sprite_tecla_interac, sprite_tecla_aceptar;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inicio de control de musica

audio_channel_num(20); // Cantidad de sonidos soportados simultaneamente en el juego.

// Para manejo de sacar y poner la mùsica y sonidos
vol = 1;
audio_master_gain(vol);

// Se carga primero la música y los sonidos.
if not( audio_group_is_loaded(group_musica) ){ 

    audio_group_load(group_intro); // Este grupo contiene solo la música de la intro, de esta manera carga rápido y se usa en el momento, si lo tengo en el de música no se reproduce porque hay un tiempo de carga
    audio_group_load( group_musica ); 
    
}


// Se inicializan los atributos usados para el control de los sonidos y la música.

musica_principal = 0; // Es la música que se usa de fondo y varia de room en room.
musica_secundaria = 0; // Usada como auxiliar cuando se quiere guardar el ID de una música
musica_string_aux = 0; // Usado cuando se realizan cambios de la música y se arma un string segun el sector que se está.

// Se carga la música del intro y se hace un efecto "fade in" de 5 segundos.
musica_principal = audio_play_sound(music_intro, 1, true);
audio_sound_gain(musica_principal, 0, 0);
audio_sound_gain(musica_principal, volumen_musica, 3000);

// Llamada a alarma que controla si la musica principal suena, a veces no sucede por error del navegador
alarm[5] = 20;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Control de reproducción de música principal

if not ( audio_is_playing(musica_principal) ){

    audio_stop_sound(musica_principal); // Se detiene primero la música que estaba sonando

    musica_principal = audio_play_sound(musica_string_aux, 100, true);
    
    // Se setea que el volumen sea cero al principio y luego se lo va incrementando
    audio_sound_gain(musica_principal, 0, 0);
    audio_sound_gain(musica_principal, volumen_musica, 250);
}

alarm[5] = 30;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Manejo de eventos animados de fondo


// Dependiendo del tipo de fondo usado, se ve si hay que hacer alguna acción.
switch( tipo_fondo ){
    
    // Cueva
    case 3:{
      
        instance_create( 0, 0, control_cueva_ojos );
        timeline_running = false;
        
        break;
    
    }
    
    // Aldea
    case 4:{
    
        timeline_running = false;
        instance_create( 0, 0, control_aldea_humo );
        
        break;
    
    }
    
    // Bosque Oscuro
    case 5:{
    
        instance_create( 0, 0, control_oscuro_niebla );
        timeline_running = false;
        
        break;
    
    }
    
    // Menú principal.
    case 6:{
    
        timeline_index = time_background_animacion;
        timeline_position = 800;
        timeline_running = true;
        
        break;
    
    }
    
    // Cualquier otro que no tenga efectos.
    default:{
    
        timeline_running = false;
    
        break;
    
    }

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inicio animación desbloqueo bloque extra

timeline_index = time_desbloquear_extra;
timeline_position = 0;
timeline_running = true;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vuelve la música principal luego de morir

// Se vuelve a la música principal con un efecto de fade-in por donde iba antes de morir
audio_resume_sound( musica_principal );

audio_sound_gain( musica_principal, 0, 0 );
audio_sound_gain( musica_principal, volumen_musica, 250 );
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Se detiene la musica secundaria

audio_stop_sound(musica_secundaria);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Cambio de música según el room

audio_stop_sound(musica_principal); // Se detiene primero la música que estaba sonando

musica_principal = audio_play_sound(musica_string_aux, 1, true);

// Se setea que el volumen sea cero al principio y luego se lo va incrementando
audio_sound_gain(musica_principal, 0, 0);
audio_sound_gain(musica_principal, volumen_musica, 250);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Consideraciones al empezar un room

if( room != room_intro and room != room_final){
    
    switch(room){
        
        /*--------------------------
        ---     Menú Principal  ----
        --------------------------*/
        case room_menu_principal:{
            
            // Se indica que aún no puede usarse el menú y se llama a la alarma correspondiente que chequea cuando si.
            with(control_menu_pausa){
            
                menu_on = false; 
                alarm[0] = 10;
            
                // Se setean los valores iniciales para el manejo del menu y puntero.
                menu_submenu = 0;
                menu_opcion = 0;
                menu_move = false;
            
            
                //Se cambia el inicio dependiendo si viene o no de la cutscene final del juego
                if( other.mostrar_creditos_final == false ){
                    
                    // Se crean los carteles con caida necesarios.
                    var cartel_menu_id;
                    
                    drop_cartel( 0, 432, 0, 136 ); // Título del juego
                    cartel_menu_id = drop_cartel( 1, 32, 0, 80 );  // Opciones del menú principal del juego
                
                        
                    x_puntero = cartel_menu_id.x + sprite_get_width(sp_cartel_menu) + 20 ;
                    y_puntero = ( ( sprite_get_height(sp_cartel_menu) - 32 ) / 2 ) + 16;
                
                }
                else{                    
                    
                    aux_sector_actual = 1;
                    with(other){
                    
                        mostrar_creditos_final = false;
                        sector_actual = 1;
                        nivel_actual = 1;
                        
                    }
                    
                    event_perform(ev_alarm, 6 );
                    
                }
                    
            }
            
            en_menu = true;
        
            
            break;
        
        }
        
        /*--------------------------------
        ---     Selección Sectores   ----
        --------------------------------*/
        case room_seleccion_sectores:{ 
            
            // Se cargan los datos requeridos almacenados en el arreglo "datos" (en el que caso que no exista, se muestra el mensaje de error correspondiente).
            if( file_exists("save.data") ){ cargar_sectores(datos[0]); }
            else{ show_error("No se encuentra el archivo 'save.data'. #La aplicación se cerrará.", true); }
            
            //Se crean los carteles necesarios.
            
            drop_cartel(5, 16, 0, 76); // Volver
            drop_cartel(6, 584, 0, 76); // Cantidad ruedas rotarias total en el juego

            //---&gt; Si el jugador ha conseguido lo necesario para desbloquear el sector extra, se hace la animación correspondiente, caso contrario se sigue con normalidad.
            if( juego_total_ruedas == 165 and verificar_desbloqueo( "save.data", datos[0], 1, 6 ) == false ){ 
            
                alarm[3] = 15;
            
            }
            else{
            
                // Se indica que aún no puede usarse el menú y se llama a la alarma correspondiente que chequea cuando si.
                with(control_menu_pausa){
                
                    menu_on = false;
                    alarm[0] = 10;
                    
                    // Se setean los valores iniciales para el manejo del menu y puntero.
                    menu_submenu = 0;
                    sector_actual = aux_sector_actual;
                    menu_opcion = sector_actual;
                    menu_move = false;
                    
                    /* Se coloca el puntero teniendo en cuenta el sector en el que estaba en el caso que venía el jugador desde la pantalla de selección de niveles (en el
                    caso de venir desde el menú principal, siempre se coloca el puntero al lado del primer sector).*/
                    with( ob_bloque_sector ){
                    
                        if( numero == sector_actual ){
                                         
                            other.x_puntero = xstart + 20 + sprite_get_width(sp_bloque_sector);
                            other.y_puntero = ystart + ( sprite_get_height(sp_bloque_sector) / 2 );
                        
                        }
                    
                    }
                
                }
            
            }
            
            en_menu = true;
            
            break; 
         
               
        }
        
        /*-------------------------------
        ---     Selección Niveles   ----
        -------------------------------*/
        case room_seleccion_niveles:{
        
            control_menu_pausa.can_pausa = false;
        
            // Se cambia el valor de la variable global del sector actual que se esta con la usada de forma auxiliar
            sector_actual = control_menu_pausa.aux_sector_actual;
       
            // Se verifica (en el caso que lo haya) que el siguiente sector esta desbloqueado.
            if( sector_actual != 6 ){ sector_siguiente_desbloqueado = verificar_desbloqueo_siguiente_sector("save.data", datos[0], sector_actual); }
            
            // Se les asigna a los bloque de nivel, el número correspondiente que tienen según el sector que están.
            with(ob_bloque_nivel){ numero_juego = numero + ( sector_actual - 1 ) * 11; }
            
            // Se cargan los datos necesarios de cada nivel
            cargar_niveles( datos[1], sector_actual );
            
            //Se crean los carteles necesarios.
            drop_cartel(5, 16, 0, 76); // Volver
            drop_cartel(8, 16 + sprite_get_width(sp_cartel_colgante_chico) + 80, 0, 76); // Nombre del sector
            drop_cartel(7, 584, 0, 76); // Cantidad ruedas rotarias total en el sector
        
            //---&gt; Si el jugador ha conseguido lo necesario para desbloquear el nivel extra, se hace la animación correspondiente, caso contrario se sigue con normalidad.
            if( sector_total_ruedas[sector_actual] == 30 and verificar_desbloqueo( "save.data", datos[1], sector_actual, 11 ) == false ){ 
            
                control_menu_pausa.menu_opcion = 11;
                alarm[3] = 15;
            
            }
            else{
                  
                // Se indica que aún no puede usarse el menú y se llama a la alarma correspondiente que chequea cuando si.
                with(control_menu_pausa){
                
                    menu_on = false;
                    alarm[0] = 10;
                    
                    // Se setean los valores iniciales para el manejo del menu y puntero.
                    menu_submenu = 0;
                    menu_opcion = nivel_actual;
                    menu_move = false;
                    
                    opcion_siguiente_sector = other.sector_siguiente_desbloqueado; // Se le manda el mismo valor que indica si el siguiente sector esta habilitado.
                    
                    /* Se coloca el puntero teniendo en cuenta el nivel en el que estaba  (en el caso de venir desde la selección de sectores, siempre se coloca 
                    el puntero al lado del primer nivel).*/
                    with( ob_bloque_nivel ){
                    
                        if( numero == nivel_actual ){
                                         
                            other.x_puntero = xstart + 20 + sprite_get_width(sp_bloque_nivel);
                            other.y_puntero = ystart + ( sprite_get_height(sp_bloque_nivel) / 2 );
                        
                        }
                    
                    }
                    
                
                }
                
            }
            
            en_menu = true;
            
            break;
        
        } 
        
        
        /*-------------------------------
        ---     Niveles  ----
        -------------------------------*/
        default:{
        
            en_menu = false;
        
            break;
        
        }
    
    
    }

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Manejo de la música al empezar un room

// Si aún esta sonando (por más que este sin volumen) la musica de conteo de orbes, se detiene a cierto tiempo (para que se produzca el efecto fade out).
if( audio_is_playing(music_conteo_orbes) ){ alarm[1] = 30; }

/* Si se comienza un room que cooresponde a uno de "nivel", se verifica si hay que hacer algun cambió con la música. 
Caso contrario, se verifica si hay que poner de las de menu. */
if( string_count("nivel_", room_get_name(room) ) ){

    // Se controla si esta sonando la música del sector que le corresponde.
    musica_string_aux = asset_get_index( "music_sector_" + string(sector_actual) );
    if not( audio_is_playing(musica_string_aux) ){ alarm[0] = 10; }

    // Si esta en algunos de los niveles primeros de algún sector, se hace el efecto "fade out" y se cambia.
    if(  (nivel_actual mod 11 ) == 1 ){
        
        audio_sound_gain(musica_principal, 0, 250); // Se va dreduciendo lentamente
        alarm[0] = 10; // Se llama a la alarma que se hace cargo de reproducir la nueva música
    
    }
    
    
}
else{

    if( room != room_intro and room != room_final){ musica_string_aux = music_menu; }
    else{ musica_string_aux = music_intro }

    if not ( audio_is_playing( musica_string_aux ) ){ 
        
        audio_sound_gain(musica_principal, 0, 500); // Se va dreduciendo lentamente
        alarm[0] = 15; // Se llama a la alarma que se hace cargo de reproducir la nueva música
            
    }
    

}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if( path_exists(pth_jug_fin_nivel) ){ path_delete(pth_jug_fin_nivel); } // Destruye el path usado por el jugador al llegar al punto de entrega (si existe).
    
if(ds_exists(cola_flechas, ds_type_queue) ){ ds_queue_destroy(cola_flechas);} // destruye en memoria la cola creada.
    
if( instance_exists(surface_pausa) ){
    
    with( surface_pausa){ 
    
        sprite_delete(sprite_fondo);
        instance_destroy();
    
    }
    
}
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Marco de pantalla

draw_set_color(c_orange);
draw_line_width(0,0,0, room_alto, 3);
draw_line_width(0,room_alto-2, room_ancho, room_alto-2, 3);
draw_line_width(room_ancho-2, room_alto, room_ancho-2, 0, 3);
draw_line_width(room_ancho, 0, 0, 0, 3);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Fondo y borde de pantalla

// Se dibuja lo correspodiente a niveles si existe el personaje que controla el jugador.
if( en_menu == false  ){

    //---&gt; Cuadro de fondo para la cantidad de orbes.
    draw_sprite(sp_cartel_piedra_chico, 0, 2, 2 );
                        
    //---&gt; Se dibuja la imagen representativa de las orbes.
    draw_sprite(sp_orbe, 1, 36, 22);      
                        
    //---&gt; Cantidad de orbes recogidas en el nivel / orbes total del nivel
    draw_set_font(fn_principal_normal);
    draw_set_halign(fa_center);
    draw_set_valign(fa_top);
    draw_set_color(c_white);
        
    draw_text_transformed( 42, 40, string_replace( string_format(nivel_orbes_cantidad_actual, 2, 0), ' ', '0') + "/" + string_replace( string_format(nivel_orbes_cantidad_total, 2, 0), ' ', '0'), 1, 1, 0 );
    
}
else{

    // En el caso que se este en la seleccion de niveles, se dibujan algunas cosas extra.
    if( room == room_seleccion_niveles ){
    
        //---&gt; Parte Inferior( Anterior Sector - Siguiente Sector )    
           
        draw_set_font(fn_principal_normal);
        draw_set_halign(fa_center);
        draw_set_valign(fa_middle);
        draw_set_color(c_white);
        
        var apuntando = control_menu_pausa.menu_opcion;
        
        // Los carteles de "Anterior Sector" y "Siguiente" se dibujan segun el caso de estar en el primero, el último o en alguno en el medio.
        switch(sector_actual){
        
            case 1:{
            
                // Siguiente Sector ( si se está desbloqueado)
                if( sector_siguiente_desbloqueado == true ){ 
                    
                    if( apuntando != 13 ){ draw_sprite( sp_anterior_siguiente_sector, 0, 556, room_alto - 8); }
                    else{
                    
                        image_speed = 0.1;
                        draw_sprite( sp_anterior_siguiente_sector, -1, 556, room_alto - 8);
                    
                    }
                    
                }
                
                break;
            
            }
            
            case 6:{
            
                // Anterior Sector
                if( apuntando != 12 ){ draw_sprite_ext( sp_anterior_siguiente_sector, 0, 244, room_alto - 8, -1, 1, 0, -1, 1); }
                else{
                    
                    image_speed = 0.1;
                    draw_sprite_ext( sp_anterior_siguiente_sector, -1, 244, room_alto - 8, -1, 1, 0, -1, 1);
                    
                }
            
                break;
            
            }
            
            default:{
            
                // Anterior Sector
                if( apuntando != 12 ){ draw_sprite_ext( sp_anterior_siguiente_sector, 0, 244, room_alto - 8, -1, 1, 0, -1, 1); }
                else{
                
                    image_speed = 0.1;
                    draw_sprite_ext( sp_anterior_siguiente_sector, -1, 244, room_alto - 8, -1, 1, 0, -1, 1);
                
                }
            
                // Siguiente Sector ( si se está desbloqueado)
                if( sector_siguiente_desbloqueado == true ){ 
                
                   if( apuntando != 13 ){ draw_sprite( sp_anterior_siguiente_sector, 0, 556, room_alto - 8); }
                   else{
                   
                        image_speed = 0.1;
                        draw_sprite( sp_anterior_siguiente_sector, -1, 556, room_alto - 8);
                   
                   }
                      
                }
                
                break;
            
            }
        
        }
    
    }


}
        
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="77">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Se saca o pone la musica o sonido

if( vol != 0 ){ vol = 0; audio_master_gain(vol); }
else{ vol = 1; audio_master_gain(vol); }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="69">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reiniciar juego

if( prueba == true ){
    
    if( path_exists(pth_jug_fin_nivel) ){ path_delete(pth_jug_fin_nivel); } // Destruye el path usado por el jugador al llegar al punto de entrega (si existe).
    if(ds_exists(cola_flechas, ds_type_queue) ){ ds_queue_destroy(cola_flechas);} // destruye en memoria la cola creada.
    
    audio_stop_all();
        
    game_restart();

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
