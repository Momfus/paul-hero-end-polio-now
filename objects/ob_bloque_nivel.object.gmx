<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sp_bloque_nivel</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>parent_rebote</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Atributos de Nivel

timeline_index = time_vibrar; // Animación usada cuando esta bloqueado y se selecciona.

numero = 0; // Cualquier valor entero, el cero es de incio.
numero_juego = 0; // Valor usado al cargar datos e ir a los niveles requeridos, varía según el sector que se encuentra y se modifica al crearse el room.

desbloqueado = false; // El "numero 1" debe estar en "true".

ruedas_obtenidas = 0; // El total es siempre 3.

extra = false; // Señala si es un nivel extra (el número 11 siempre lo es)

// Los siguientes atributos son para controlar el efecto de rebote
image_speed = 0;
etapa = 3; // Para manejar el efecto de rebote (menos a 3) y cuando se termina la animación. Se comienza en 3 para que quede quieto en un inicio.
vel = 0; // Velocidad en que se mueve el cartel al caer (se inicializa en cero pero en la alarma que se llama se coloca otro valor, dando un efecto cascada con el resto)..

posicion_final_y = y;  // Se toma como posición final la que tiene al colocarse en el room

y = 0 - ( room_alto - posicion_final_y ); // Se coloca el objeto sobre la pantalla para que luego caiga donde estaba de forma ordenada.

alarm[1] = 1; // Se llama la alarma que hace caer los bloques.

apuntado = false; // Si es true, se resalta el numero cambiándolo de coloir

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Se activa caida de los bloques

etapa = 0; // Se activa la animación.
vel = 30 + irandom(10); 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Manejo de la animación del objeto y posicionamiento al rebotar

// Si la etapa no es "3", se realiza la animación, sino se hace lo necesario según que tipo de cartel es.
if( etapa != 3 ){

    switch( etapa ){
    
        // Bajando pasando por 16 pixeles la posición deseada.
        case 0:{
        
            if( y &lt; ( posicion_final_y + 16 - vel ) ){ y += vel; if( vel &lt; 20 ){ vel += grav; } }
            else{ etapa++; vel = 10; }
            
            break;
        
        }
        
        // Sube hasta 8 pixeles por encima de la posición deseada
        case 1:{
        
            if( y &gt; ( posicion_final_y - 8 ) ){ y -= vel; if( vel != 0 ){ vel -= grav; } }
            else{ etapa++; vel = 5; }
            
            break;
        
        }
        
        // Baja hasta la posición deseada
        case 2:{
        
            if( y &lt; posicion_final_y ){ y += vel; if( vel &lt; 20 ){ vel += grav; } }
            else{ etapa++; y = posicion_final_y }
        
            break;
        
        }
    
    }
    
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Manejo de imagen


// Se verifica si el nivel está bloqueado o no, para saber si se dibujar el candado.
if( desbloqueado == true ){
        
    // Se coloca el número del sector correspondiente.
    draw_set_font(fn_principal_big);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    if( apuntado == false ){ draw_set_color(c_white); }
    else{ draw_set_colour(c_yellow); }
    
        
    // El sprite es diferente si el nivel es extra o no
    if( extra == false ){ 
    
        draw_sprite(sp_bloque_nivel, 0, x, y); 
        draw_text( x + 40, y + 34, numero);
        
    }
    else{ 
    
        draw_sprite(sp_bloque_nivel, 2, x, y);
        draw_text_transformed( x + 46, y + 40, numero, 0.7, 0.9, 0); 
    }
         
        
    // Se dibujan la cantidad de ruedas rotarias obtenidas en el nivel.
    switch(ruedas_obtenidas){
        
        case 0:{
            
            draw_sprite(sp_rueda_rotaria, 1, x - 16, y + 52);
            draw_sprite(sp_rueda_rotaria, 1, x + 24, y + 52);
            draw_sprite(sp_rueda_rotaria, 1, x + 64, y + 52);
        
            break;
                
        }
            
        case 1:{
            
            draw_sprite(sp_rueda_rotaria, 0, x - 16, y + 52);
            draw_sprite(sp_rueda_rotaria, 1, x + 24, y + 52);
            draw_sprite(sp_rueda_rotaria, 1, x + 64, y + 52);
        
            break;
            
        }
            
        case 2:{
            
            draw_sprite(sp_rueda_rotaria, 0, x - 16, y + 52);
            draw_sprite(sp_rueda_rotaria, 0, x + 24, y + 52);
            draw_sprite(sp_rueda_rotaria, 1, x + 64, y + 52);
        
            break;
            
        }
            
        case 3:{
            
            draw_sprite(sp_rueda_rotaria, 0, x - 16, y + 52);
            draw_sprite(sp_rueda_rotaria, 0, x + 24, y + 52);
            draw_sprite(sp_rueda_rotaria, 0, x + 64, y + 52);
        
            break;
            
        }
        
    }

}
else{

    // El sprite es diferente si el nivel es extra o no
    if( extra == false ){ draw_sprite(sp_bloque_nivel, 1, x, y); }
    else{ draw_sprite(sp_bloque_nivel, 3, x, y); }

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>56,56</point>
  </PhysicsShapePoints>
</object>
